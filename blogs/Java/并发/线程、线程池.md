---
Java 线程、线程池
---

#### 目录

1. 前言
2. 线程的创建
3. Callable 与 Future
4. 线程池
5. 参考

#### 前言



#### 线程的创建

我们知道，线程的创建有两种方式：一种是继承 Thread 类，另一种是实现 Runnable 接口。但是这两种方式有一个共同的缺陷，那就是在执行任务后无法获取执行结果（两者 run 方法的返回类型都是 void ）。于是在 JDK 5 就引入了 Callable 和 Future。

#### Callable 与 Future

##### Callable

```java
public interface Callable<V> {
    V call() throws Exception;
}
```

Callable 是一个泛型接口，你可以完全把它理解为一个有返回类型并且可抛异常的 Runnable。

那么是如何获取 Callable 的返回结果呢？通常是通过 FutureTask 这个中间媒介来实现的。

##### FutureTask

FutureTask 实现了 Runnable 和 Future 接口，所以我们可以直接用 Thread 来执行它，也可以使用 ExecuteService 来执行。这里就以 Thread 包装来执行：

```java
public class ThreadDemo {
    public static void main(String[] args) throws Exception {
        Callable<Integer> call = () -> {
            System.out.println("线程执行...");
            Thread.sleep(2000);
            return 1;
        };
        FutureTask<Integer> task = new FutureTask<>(call);
        new Thread(task).start();
        System.out.println(task.get());
    }
}
```

##### Future

Future 的核心思想是：一个方法，计算过程可能非常耗时，等待方法返回显然不可取。可以在执行方法的时候，立马就返回一个 Future 对象，通过这个 Future 对象去控制方法的计算过程。

```java
public interface Future<V> {
  
    /**
     * 取消任务
     */
    boolean cancel(boolean mayInterruptIfRunning);

    /**
     * 判断是否取消
     */
    boolean isCancelled();

    /**
     * 判断是否已完成
     */
    boolean isDone();

    /**
     * 获取任务结果，如果未完成，则等待
     */
    V get() throws InterruptedException, ExecutionException;

    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

#### 线程池

线程池是为了线程的复用，避免重复创建和销毁线程所带来的性能损耗。

##### ThreadPoolExecutor

ThreadPoolExecutor 类是线程池中最核心的一个类，它提供了四个构造方法：

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue){};
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory){};
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              RejectedExecutionHandler handler){};                              
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler){};
```

前面三个构造方法都是通过调用第四个构造方法来进行初始化工作的，下面解释一下各个参数的含义：

- corePoolSize 

  核心线程的大小。在创建线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了 prestartAllCoreThreads() 或者 prestartCoreThread() 方法，从这两个方法名就可以看出，是预创建线程的意思。即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为零，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中。

- maximumPoolSize

  线程池中的最大线程数，当任务数量超过最大线程数时，其他任务可能就会被阻塞。最大线程数 = 核心线程 + 非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。

- keepAliveTime

  非核心线程的超时时长，当执行时间超过这个时间时，非核心线程就会被回收。当 allowCoreThreadTimeOut 设置为 true 时，此属性也作用在核心线程上。

- unit

  参数 keepAliveTime 的时间单位，为 TimeUnit 类中的枚举值。

- workQueue

  一个阻塞队列，用来存储等待执行的任务。一般来说，阻塞队列使用 LinkedBlockingQueue 和 SynchronousQueue 较多。

- threadFactory

  线程工厂，主要用来创建线程。

- handler

  表示当拒绝处理任务时的策略，有以下四种取值：

  1. ThreadPoolExecutor.AbortPolicy

     丢弃任务并抛出 RejectedExecutionException 异常。

  2. ThreadPoolExecutor.DiscardPolicy

     丢弃任务，但不抛异常。

  3. ThreadPoolExecutor.DiscardOldestPolicy

     丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。

  4. ThreadPoolExecutor.CallerRunsPolicy

     由调度线程处理该任务。



#### 参考

[Java并发编程：线程池的使用](https://www.cnblogs.com/dolphin0520/p/3932921.html)