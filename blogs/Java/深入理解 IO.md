---
深入理解 IO
---

#### 目录

1. IO 读写的基本原理
2. 四种主要的 IO 模型

#### IO 读写的基本原理

为了避免用户进程直接操作内核，保证内核安全，操作系统将内存（虚拟内存）划分为两部分：一部分是内核空间（Kernel-Space），另一部分是用户空间（User-Space）。在 Linux 系统中，内核模块运行在内核空间，对应的进程处于内核态；用户程序运行在用户空间，对应的进程处于用户态。

操作系统的核心是内核程序，它独立于普通的应用程序，既有权限访问受保护的内核空间，也有权限访问硬件设备，而普通的应用程序并没有这样的权限。内核空间总是驻留在内存中，是为操作系统的内核保留的。应用程序不允许直接在内核空间区域进行读写，也不允许直接调用内核代码定义的函数。每个应用程序进程都有一个单独的用户空间，对应的进程处于用户态，用户态进程不能访问内核空间中的数据，也不能直接调用内核函数，因此需要将进程切换到内核态才能进行系统调用。

内核态进程可以执行任意命令，调用系统的一切资源，而用户态进程只能执行简单的运算，不能直接调用系统资源，那么问题来了：用户态进程如何执行系统调用呢？答案是：用户态进程必须通过系统调用（System Call）向内核发出指令，完成调用系统资源之类的操作。

用户程序进行 IO 的读写依赖于底层的 IO 读写，基本上会用到底层的 read 和 write 两大系统调用。

操作系统层面的 read 系统调用并不是直接从物理设备把数据读取到应用的内存中，write 系统调用也不是直接把数据写到物理设备。上层应用无论是调用 read 还是 write，都会涉及缓冲区。具体来说，上层应用通过 read 系统调用把数据从内核缓冲区复制到应用程序的进程缓冲区，通过 write 系统调用把数据从应用程序的进程缓冲区复制到操作系统的内核缓冲区。

简单来说，应用程序的 IO 操作实际上不是物理设备级别的读写，而是缓存的复制。

为什么设置那么多的缓冲区，导致读写过程那么麻烦呢？

缓冲区的目的是减少与设备之间的频繁物理交换。计算机的外部物理设备与内存和 CPU 相比，有着非常大的差距，外部设备的直接读写涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少底层系统的频繁中断所导致的时间损耗、性能损耗，出现了内核缓冲区。

操作系统会对内核缓冲区进行监控，等待缓冲区到达一定数量的时候，再进行 IO 设备的中断处理，集中执行物理设备的实际 IO 操作，通过这种机制来提升系统的性能。至于具体什么时候执行系统中断（包括读中断、写中断）则由操作系统的内核来决定，应用程序不需要关心。

上层应用使用 read 系统调用时，仅仅把数据从内核缓冲区复制到应用的缓冲区；上层应用使用 write 系统调用时，仅仅把数据从应用的缓冲区复制到内核缓冲区。

#### 四种主要的 IO 模型

常见的 IO 模型有四种：同步阻塞 IO、同步非阻塞 IO、IO 多路复用和异步 IO。

首先，解释一下阻塞与非阻塞。阻塞 IO 指的是需要内核 IO 操作彻底完成之后才返回到用户空间执行用户程序的操作指令。“阻塞” 指的是用户程序（发起 IO 请求的进程或者线程）的执行状态。可以说传统的 IO 模型都是阻塞 IO 模型，并且在 Java 中默认创建的 Socket 都属于阻塞  IO 模型。

其次，解释一下同步与异步。简单来说，可以将同步与异步看成发起 IO 请求的两种方式。同步 IO 是指用户空间（进程或者线程）是主动发起 IO 请求的一方，系统内核是被动接收方。异步 IO 则反过来，系统内核是主动发起 IO 请求的一方，用户空间是被动接收方。