---
集合源码口水话
---

目录

1. ArrayList
2. Vector
3. LinkedList
4. HashMap

#### ArrayList

ArrayList 实现了 List 接口，RandomAccess 接口，可以插入空数据以及支持随机访问。它相当于一个动态数组，初始化时是一个空数组，在第一次 add 时设置初始容量为 10，每次扩容都增加到原来的 1.5 倍。简单的 add 就是在 elementData 数组末尾添加一个数据，size++；指定 index 添加数据，就需要拷贝 index 后面的数据后移一位。在删除的时，如果是删除 null，就遍历数组找到第一个 null 值删除，否则就遍历比较 equals 删除指定 index 的数据，其实也就是拷贝 index 后面的数据前移一位。删除数据时，最好使用迭代器来做，避免 CurrentModifyException，它并不只是在并发时才会抛出的，单线程也可能抛出，其实内部是比较 expectedModCount 和 modCount 是否相等来判断的。ArrayList 的性能损耗就来源于数组拷贝，在适当情况下，可以初始化时指定容量大小，避免不必要的扩容操作。其实呢，ArrayList 还有一个缺点，就是不能自动缩容，但是我们可以手动调用 trimToSize 来缩容至当前 size 大小。

还有一点是 elementData 是用 transient 修饰的，也就是拒绝数据被自动序列化，因为 ArrayList 并不是所有位置都有数据，所以没必要全部序列化，应该只序列化有数据的部分，所以它重写了 writeObject/readObjet 方法。

#### Vector

Vector 感觉是一个被人抛弃的类，它在初始化时直接设置了数组初始容量为 10，在它的 get/add 等方法都加了 synchronized，完全可以看成是一个加锁的 ArrayList。

不同的是，它在扩容时默认是直接加倍的，当然这个是可以控制的，在构造方法中可以传一个增长数，这个数是需要大于 1 的，不然就按 1 处理。比如是 0.75，每次扩容就加 1，是 5 呢每次扩容就加 5。

当然，想让 ArrayList 变成线程安全的，还可以使用 Collections.synchronizedList 来做，或者呢，使用 CopyOnWriteArrayList。

#### LinkedList

LinkedList 实现了 Deque 接口，说明它是一个双向链表，每一个 Node 节点都有 prev 和 next 指针，每次 add 或者 remove 时都需要更新前驱和后指针，在指定 index 位置删除时，会区分 index 如果是靠头部比较近，就从头 first 节点遍历删，否则从尾部 last 节点删。使用迭代器时，也是可以使用 ListIterator 从头或从尾遍历。

它在新增和删除时，时间复杂度 O(1)，而在查询时时间复杂度 O(n)。

#### HashMap

HashMap 底层数据结构是数组 + 链表 + 红黑树。数组的主要作用是方便快速查找，时间复杂度是 O(1)，默认大小是 16，数组的下表索引是通过 key 的 hashCode 计算出来的，数组元素叫做 Node，当多个 key 的 hashCode 一致，但 key 值不相同时，即发生了 hash 冲突时，单个 Node 就会转化为链表，链表的查询复杂度是 O(n)，当链表的长度大于等于 8 并且数组的大小超过 64 时，链表就会转化为红黑树，红黑树的查询复杂度是 O(log(n))，简单来说，最坏的查询次数相当于红黑树的最大深度。

HashMap 非线程安全，如果需要满足线程安全，可以用 Collections.synchronizedMap 使得 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。