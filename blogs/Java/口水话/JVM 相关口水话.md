JVM 相关口水话

#### 目录

1. 内存区域
2. 内存模型
3. 内存分配回收策略
4. Java 对象的创建、内存布局和访问定位
5. GC
   1. 引用计数及可达性分析
   2. 垃圾回收算法
   3. G1 及 ZGC
6. 类加载机制
7. 双亲委派模型
8. 编译器优化
9. 虚拟机相关
   1. HotSpot 及 JIT
   2. Dalvik
   3. ART 及 AOT

#### 内存区域

Java 中的运行时数据可以划分为两部分，一部分是线程私有的，包括虚拟机栈、本地方法栈、程序计数器，另一部分是线程共享的，包括方法区和堆。

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行指示器。虚拟机栈描述的是 Java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接地址、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈桢在虚拟机中入栈和出栈的过程。本地方法栈和虚拟机栈所发挥的作用是非常相似的，只不过本地方法栈描述的是 Native 方法执行的内存模型。

Java 堆是所有线程共享的一块数据区域，主要用来存放对象实例。它也是垃圾收集器管理的主要区域，从内存回收的角度来看，由于现代收集器基本上都采用分代回收，所以 Java 堆还可以细分为新生代和老年代。再细致一点还可以把新生代划分为 Eden 区、From Survivor 区和 To Survivor 区。从内存分配的角度来看，线程共享的 Java 堆中可能划分为多个线程私有的分配缓冲区 TLAB。不过不论如何划分，都与存放内容无关，无论哪个区域，存放的都是对象实例，进一步划分的目的是为了更好的回收内存或者更快的分配内存。方法区是用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。JVM 对方法区的限制比较宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾回收。相对而言，垃圾回收在这个区域是比较少出现的。运行时常量池是方法区的一部分，它用来存储编译期生成的各种字面量和符号引用。运行时常量池相比 Class 文件常量池一个重要的特点是具备动态性，也就是在运行期间也可能将新的常量放入池中，比如 String 的 intern 方法。

#### 内存模型

JMM 内存模型是用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各个平台下都能达到一致的内存访问效果。

Java 内存模型规定了所有的共享变量都是存储在主内存，每个线程还有自己的工作内存，线程的工作内存保存了该线程使用到的共享变量的主内存副本拷贝，线程对变量的操作都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的数据，线程间变量值的传递均需要主内存来完成。

那么为什么要这么做呢？

其实就要讲到一些硬件知识了，我们知道 CPU 执行的速度是远超于内存访问速度，为了中和这种速度差异，在 CPU 和内存直接会加入多个 CPU 缓存，比如 L1、L2、L3。CPU 在处理数据时会先把内存中的数据读到自己的 CPU 缓存中，然后在缓存中进行操作数据，最后再把数据同步到内存中。这里，就可以把 CPU 的缓存看成是线程的工作内存，而把内存看成是主内存，虽然这个说法并不严谨，但是易于理解。

#### 内存分配回收策略

内存分配回收策略包含三点：

1. 对象优先在 Eden 区分配

   准确的来说，是优先在 Eden 区的 TLAB 上分配，如果 Eden 区没有足够的空间进行分配时，就会触发一次 Minor GC。

2. 大对象直接进入老年代

   所谓的大对象是指需要连续大量内存空间的 Java 对象，比如数组，一般来说，超过 3M 的对象会直接在老年代进行分配。

3. 长期存活的对象进入老年代

   既然虚拟机采用了分代收集的思想来管理内存，那么内存回收就必须得识别哪些对象应放在新生代还是老年代。为了做到这一点，虚拟机给每个对象定义了一个对象年龄计数器。如果对象在 Eden 出生并经过一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将会被移到 Survivor 空间中，并且对象年龄设置为 1.对象每在 Survivor 区熬过一次 Minor GC，年龄就会增加 1。当年龄增加到一定程度，默认是 15，就将会晋升到老年代中。

最后讲一下 Minor GC 和 Full GC。

Minor GC 是指发生在新生代的垃圾回收动作，因为 Java 对象大多都是朝生夕死的，所以 Minor GC 比较频繁，回收速度也比较快。

Full GC/Major GC 指发生在老年代的 GC，出现 Full GC 经常会伴随着至少一次的 Minor GC，Full GC 一般会比 Minor GC 慢十倍以上。

#### Java 对象的创建、内存布局和访问定位

先说对象创建，在虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过了，如果没有就走类加载流程。在类加载检查通过之后，虚拟机就会为新生对象分配内存，对象所需内存在类加载完成之后就确定了。为对象分配内存空间就等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有指针碰撞和空闲列表两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否具有压缩整理功能决定。对象创建在虚拟机是非常频繁的行为，即使是仅仅修改了一个指针指向的位置，在并发情况下也不是线程安全的。解决方案有两种，一种是采用 CAS 配上失败重试，另一种是使用线程私有的分配缓冲区 TLAB。

接着是对象的内存布局，在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头、实例数据和对其填充。可以使用 OpenJDK 开源的 JOL 工具查看对象的内存布局，直接 new Object 所占用的大小为 16 字节，即 12 个字节的对象头 + 4 个字节的对其填充。JOL 对分析集合源码扩容、HashMap 的 hash 冲突等非常有用。

最后是对象的访问定位，Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象，由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有规定这个引用应该通过什么方式去定位和访问堆中的对象，所以对象访问方式也是取决于虚拟机实现而定。目前主流的方式有使用句柄和直接指针两种。使用句柄，就是相当于加了一个中间层，在对象移动时只会改变句柄中的实例数据的指针，reference 本身不需要改变。HotSpot 使用的是第二种，使用直接指针的方式访问的最大好处就是速度很快。

#### GC

在垃圾收集器回收对象时，先要判断对象是否已经不再使用了，有引用计数法和可达性分析两种。

##### 引用计数及可达性分析

引用计数法就是给对象添加一个引用计数器，每当有一个地方引用时就加一，引用失效时就减一。引用计数实现简单，判断效率也很高，但是  JVM 并没有采用引用计数来管理内存，其中最主要的原因使它很难解决对象之间的相互循环引用问题。可达性分析的思路是通过一系列称为 GC Roots 的对象作为起始点，从这些起始点出发向下搜索，当有一个对象到 GC Roots 没有任何引用链时，即不可达，则说明此对象是不可用的。在 Java 中，可作为 GC Roots 的对象有虚拟机栈和本地方法栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象等。

但这也并不是说引用计数一无是处，在 Android 的 Framework Native 层用的智能指针。智能指针就是一种能够自动维护对象引用计数的技术，它是一个对象而不是一个指针，但是它引用了一个实际使用的对象。简单来说，就是在智能指针构造时，增加它所引用的对象的引用计数；而在智能指针析构时，就减少它所引用对象的引用对象。但是它是怎样解决相互引用问题的呢？其实是通过强弱引用来实现，也就是将对象的引用计数分为强引用计数和弱引用计数两种，其中，对象的生命周期只受强引用计数控制。比如在解决对象 A 和 B 相互引用时，把 A 看成父 B 看成子，对象 A 通过强引用计数来引用 B，B 通过若引用计数来引用 A。在 A 不再使用时，由于 B 是通过弱引用来引用它的，因此 A 的生命周期是不受 B 影响的，所以 A 可以安全的释放，在释放 A 时，同时也会释放它对 B 的强引用计数，这是 B 也可以被安全的回收了。在 Android 中，是使用 sp 来表示强引用，wp 表示弱引用。

Java 中的引用可以分为四类，强引用、软引用、弱引用和虚引用。强引用在程序中普遍存在，类似 new 的这种操作，只要有强引用存在，即使 OOM JVM 也不会回收该对象。软引用是在内存不够用时，才回去回收，JDK 提供了 SoftReference 类来实现软引用。弱引用是在 GC 时不管内存够不够用会去回收的，可以使用 WeakReference 类来实现弱引用。虚引用对对象的生命周期没有影响，只是为了能在对象回收时收到一个系统通知，可以使用 PhantomReference 类来实现虚引用。

接下来就是要将垃圾回收算法了。

##### 垃圾回收算法

垃圾回收算法主要有标记清除、复制算法、标记整理。标记清除是先通过 GC Roots 标记所存活的对象，然后再统一清除未被标记的对象，它的主要问题是会产生内存碎片。老年代使用的 CMS 收集器就是基于标记清除算法。复制算法是把内存空间划分为两块，每次分配对象只在一块内存上进行分配，在这一块内存使用完时，就直接把存活的对象复制到另外一块上，然后把已使用的那块空间一次清理掉，但是这种算法的代价就是内存的使用量缩小了一半。现代虚拟机都采用复制算法回收新生代，不过是把内存划分为了一个 Eden 区和两个 Survivor 区，比例是 8:1:1，每次使用 Eden 和其中一块 Survivor 区，也就是只有 10% 的内存会浪费掉。如果 Survivor 空间不够用，需要依赖其他内存比如老年代进行分配担保。复制算法在对象存活率比较高时效率是比较低下的，所以老年代一般不使用复制算法。标记整理算法即是在标记清除之后，把所有存活的对象都向一段移动，然后清理掉边界以外的内存区域。 

最后就是将垃圾回收算法的具体应用了，也就是垃圾收集器。

##### G1 及 ZGC

Garbage First（G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于 Region 的内存布局形式。它和 CMS 同样是一款主要面向服务端应用的垃圾收集器，不过在 JDK9 之后，CMS 就被标记为废弃了。在 G1 收集器出现之前的所有其他收集器，包括 CMS 在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），在要么就是整个 Java 堆（Full GC）。而 G1 是基于 Region 堆内存布局，虽然 G1 也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1 不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间或者老年代。收集器根据 Region 的不同角色采用不同的策略去处理。G1 会根据用户设定允许的收集停顿时间去优先处理回收价值收益最大的那些 Region 区，也就是垃圾最大的 Region 区，这就是 Garbage First 名字的由来。

G1 收集器的运作过程大致可划分为以下四个步骤：

1.初始标记

仅仅只是标记一下 GC Roots 能直接关联到的对象，这个阶段需要停顿线程，但耗时很短。

2.并发标记

从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但是可与用户程序并发执行。

3.最终标记

对用户线程做另一个短暂的暂停，用于处理在并发标记阶段新产生的对象引用链变化。

4.筛选回收

负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划。

G1 的目标是在可控的停顿时间内完成垃圾回收，所以进行了分区设计，但是 G1 也存在一些问题，比如停顿时间过长，通常 G1 的停顿时间在几十到几百毫秒之间，虽然这个数字其实已经非常小了，但是在用户体验有较高要求的情况下还是不能满足实际需求，而且 G1 支持的内存空间有限，不适用于超大内存的系统，特别是在内存容量高于 100GB 的系统上，会因内存过大而导致停顿时间增长。

ZGC 作为新一代的垃圾回收器，在设计之初就定义了三大目标：支持 TB 级内存，停顿时间控制在 10ms 之内，对程序吞吐量影响小于 15%。

#### 类加载机制

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的 Java 对象，这就是虚拟机的类加载机制。

类加载流程分为五个阶段，分别是加载、验证、准备、解析和初始化。

加载阶段，就是通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。加载阶段是开发人员可控性最强的阶段，因为开发人员可以自定义类加载器。对于数组而言，情况有所不同，数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建。

验证是链接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。它包括文件格式校验、元数据校验、字节码校验等。

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。需要注意的是，这时候进行内存分配的仅仅包含类变量，不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆上。其次，这里所说的变量初始值是该数据类型的零值。

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用以一组符号来描述所引用的目标，直接引用可以是直接指向目标的指针。

初始化阶段是执行类构造器 \<clinit>() 方法的过程。\<clinit>() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。虚拟机会保证一个类的 \<clinit>() 方法再多线程环境中被正确的加锁同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 \<clinit>() 方法，其他线程都需要阻塞等待，这也是静态内部类能实现单例的主要原因之一。

#### 双亲委派模型

双亲委派模型的工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的类加载请求最终都应该传送给顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。比如 Object 类，无论哪个类加载器去加载，应用程序各种加载器环境中都是同一个类，同时也避免了重复加载。而且，双亲委派模型也保重了 Java 程序的稳定运作。比如在应用程序中你是不能直接使用 UnSafe 这一不安全操作的类的。

双亲委派模型的实现相对简单，代码都集中在 ClassLoader 的 loadClass 方法中先检查是否已经被加载过了，如果没加载则先调用父加载器的 loadClass 方法，若父加载器为空则使用默认的启动类加载器作为父加载器。如果父加载器加载失败，抛出 ClassNotFoundException 异常，然后调用自己的 findClass 方法进行加载。

#### 编译器优化

在公司内部，我是分享过一次关于编译优化的相关知识。课题是 “从 final '能够' 提升性能，谈编译优化”。

对于 Java 代码的编译，分为前端编译和后端编译。前端编译是指通过 javac 工具，将 Java 代码转化为字节码的过程。既然 javac 负责字节码的生成，那肯定就会有一些通用的优化手段。比如常量折叠、自动装拆箱、条件编译等，其次还有 JDK9 使用 StringContactFactory 对 "+" 的重载提供的统一入口等。后端编译则指 JVM 内置的解释器和即时编译器（C1、C2）。JVM 在对代码执行的优化可以分为运行时优化和即时编译器（JIT）优化。运行时优化主要是解释执行和动态编译通用的一些机制，比如说锁机制（如偏斜锁）、内存分配机制（如 TLAB）等。除此之外，还有一些专门用于优化解释执行效率的，比如说模版解释器、内联缓存（inline cache，用于优化虚方法调用的动态绑定）。JVM 的即时编译器优化是指将热点代码以方法为单位转化成机器码，直接运行在底层硬件之上。它采用了多种优化方式，包括静态编译器可以使用的如方法内联、逃逸分析，也包括基于程序的运行 profile 的投机性优化。

下面我就主要讲一下方法内联和逃逸分析。

方法内联，它指的是在编译的过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。方法内联不仅可以消除调用本身带来的性能开销，还可以进一步触发更多的优化。因此，它可以算是编译优化里最为重要的一环。以 getter/setter 为例，如果没有方法内联，在调用 getter/setter 时，程序需要保存当前方法的执行位置，创建并压入用于 getter/setter 的栈桢、访问字段、弹出栈桢，最后再恢复当前方法的执行。而当内联了对 getter/setter 的方法调用后，上述操作就只剩下字段访问了。