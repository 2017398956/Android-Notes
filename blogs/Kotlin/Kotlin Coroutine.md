---
Kotlin Coroutine
---

#### 目录

1. 启动协程的三种方式
2. 挂起函数
2. 协程的生命周期
2. Channel
2. select
2. 

#### 启动协程

启动协程有三种方式，分别是 launch、runBlocking、async。

launch 不会阻塞当前程序的执行流程，也无法获取协程的执行结果。它有点像是生活中的射箭。

runBlocking 可以获取协程的执行结果，但这种方式会阻塞代码的执行流程，因此它一般用于测试用途，生产环境当中是不推荐使用的。

async，则是很多编程语言当中普遍存在的协程模式。它像是结合了 launch 和 runBlocking 两者的优点。它既不会阻塞当前的执行流程，还可以直接获取协程的执行结果。它有点像是生活中的钓鱼。

#### 挂起函数

挂起函数可以极大地简化异步编程，让我们能够以同步的方式写异步代码。相比 “回调地狱” 式的代码，挂起函数写出来的代码可读性更好、扩展性更好、维护性更好，也更难出错。

1. 要定义挂起函数，只需要加上 suspend 关键字。这个关键字会改变函数类型的。
2. 挂起函数拥有挂起和恢复的能力，因此对于同一行代码来说，"=" 左右两边的代码分别可以执行在不同的线程之上。
3. 挂起函数的本质，就是 Callback。在 Kotlin 中被称为 Continuation。而 Kotlin 编译器将 suspend 翻译成 Continuation 的过程，则是 CPS 转换。这里的 Continuation 是代表了 “程序继续运行下去需要执行的代码”、“接下来要执行的代码” 或者 “剩下的” 代码。

挂起函数，只能在协程当中被调用，或者是被其他挂起函数调用。但协程中的 block，本质上仍然是挂起函数。

所以我们可以认为，挂起和恢复是协程的一种底层能力；而挂起函数则是一种上层的表现形式。

#### 协程的生命周期

Job 是 launch 的返回值，Deferred 是 async 的返回值，而 Deferred 也是实现了 Job 的接口。

协程是有生命周期的，同时协程是结构化的。具体来说有以下几点：

1. Job，相当于协程的句柄，Job 与协程的关系，有点像 “遥控器与空调的关系”。
2. Job 在它的内部，维护了一系列的生命周期状态，它也对应着协程的生命周期状态。
3. 通过 Job，我们可以监测协程的状态，比如 isActive、isCancelled、isCompleted；另外，我们也可以一定程度的操控协程的状态，比如 start()、cancel()。
4. 除此之外，我们还可以通过 Job.invokeOnCompletion{ } 来监听协程执行完毕的事件；通过 Job.join() 这个挂起函数，我们可以挂起当前协程的执行流程，等到协程执行完毕以后，再恢复执行后面的代码。
5. 而对于 Deferred.await()，它的行为模式和 Job.join() 类似，只是它还会返回协程的执行结果。
6. 另外，协程是结构化的并发，这是它的第二大优势。通过分析 Job 的源码，我们发现，一个 Job 可以拥有多个 ChildJob；对应的，协程也可以拥有多个 “子协程”。
7. 结构化并发的最大优势在于，我们可以实现只控制 “父协程”，从而达到控制一堆子协程的目的。parentJob.join() 不仅仅只会等待它自身执行完毕，还会等待它内部的 job1、job2、job3 执行完毕，parentJon.cancel() 同理。

#### Channel

1. Channel 是一个管道，当我们想要用协程传递多个数据组成的流的话，就没办法用过挂起函数、async 来实现了，这时候 Channel 是一个不错的选择。
2. 我们可以通过 Channel() 这个顶层函数来创建 Channel 管道。在创建 Channel 的时候，有三个重要参数：capacity 代表了容量；onButterOverflow 代表容量满了以后的应对策略；onUndeliverdElement 则是一个异常回调。在某些场景下，比如 "发送方对于数据是否被接收方十分关心" 的情况下，可以注册这个回调。
3. Channel 有两个关键的方法：send()、receive()，前者用于发送管道数据，后者用户接收管道数据。但是，由于 Channel 是存在关闭状态的，如果我们直接使用 receive()，就会导致各种问题。因此，对于管道数据的接收方来说，我们应该尽可能的使用 for 循环、consumeEach{}。
4. Channel 是 "热" 的，这是因为不管有没有接收方，发送方都会工作。
5. Channel 其实是 SendChannel、ReceiveChannel 这两个接口的组合，我们也可以借助它的这个特点，实现 "对读取开放，对写入关闭" 的设计。

#### select

1. select 就是选择更快的结果。
2. 当 select 与 async、Channel 搭配以后，我们可以并发执行协程任务，以此大大提升程序的执行效率甚至用户体验，并且还可以改善程序的扩展性、灵活性。
3. 关于 select 的 API，我们完全不需要去刻意记忆，只需要在 Deferred、Channel 的 API 基础上加上 on 这个前缀即可。
4. 最后，我们还结合实战，分析了 select 与 async 产生太多并发协程的时候，还可以定义一个类似 fastest() 的方法，去统一取消剩余的协程任务。这样的做法，就可以大大节省计算资源，从而平衡性能与功耗。