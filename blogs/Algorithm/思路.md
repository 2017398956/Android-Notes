---
算法题思路
---

#### 目录

1. 前言
2. 树
3. 链表

#### 前言

这篇文章收录了面试必刷的算法题，而且附带简短的提示，希望你能够看到该题就能立马想到解题思路。

这些题之所以我觉得是面试必刷，是因为基本覆盖了剑指 Offer 还有就是牛客网的 [牛客网面试必刷 Top 101](https://www.nowcoder.com/exam/oj?tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=295&page=1)，可谓是经典中的经典，这些题我都整理好了，每个分类的标题就是对应的 LeetCode 链接。

#### [树](https://leetcode-cn.com/problem-list/zXvwZWi9/)

[二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

递归和迭代都很简单。

[二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

递归很简单，迭代不太好想，稍微需要注意下。

[二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

递归和迭代都很简单，它的迭代就是前序遍历的先遍历左子树的倒序，前序遍历的迭代会写，后序遍历的迭代就很简单了。

[二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

一个队列完事。

[二叉树的层序遍历||](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

同层序遍历思想，每次往列表头插即可。

[二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

同层序遍历思想，每次判断列表的 size%2 决定是头插还是尾插。

[二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

同层序遍历思想，每一层的最后一个元素即是结果。

[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

递归简单，迭代写法就是层序遍历的多少层。

[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

迭代写法和最大深度写法类似，不过需要注意，最小深度是从根节点到叶子节点，而左右子树为空时，是不构成子树的。迭代写法也是层序遍历，层序遍历的第一个叶子节点的深度就是最小深度。

[合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

递归写法很简单。

[平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

二叉树的最大深度会写，这道题也就不在话下了。

[对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

递归写法很简单，迭代写法呢？

[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

递归写法很简单。

[树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

递归写法很简单。

[验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

可以先中序遍历，然后验证其是递增的序列即可。还有一种递归写法是，验证每个节点在某个特定区间内（不能只简单判断左节点的值小于根节点，右节点的值大于根节点）。

[二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

递归写法很简单。

[二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

递归写法很简单。

[二叉搜索树中的第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

简单点就是从中序遍历序列里面找。

[二叉搜索树的第 K 大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

简单点就是从中序遍历序列里面找，还有一种解决办法是，左子树的节点数是 K-1 的根节点就是第 K 大节点了。

[从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)



[从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)



[将有序数组转换为二叉搜索数](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)



[路径总和](https://leetcode-cn.com/problems/path-sum/)

递归写法很简单。

[路径总和||](https://leetcode-cn.com/problems/path-sum-ii/)

递归+回溯。

[路径总和|||](https://leetcode-cn.com/problems/path-sum-iii/)

不会，待定。

[二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

不会，待定。

