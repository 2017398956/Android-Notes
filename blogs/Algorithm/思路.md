---
算法题思路
---

#### 目录

1. 前言
2. 树
3. 链表

#### 前言

这篇文章收录了面试必刷的算法题，而且附带简短的提示，希望你能够看到该题就能立马想到解题思路。

这些题之所以我觉得是面试必刷，是因为基本覆盖了剑指 Offer 还有就是牛客网的 [牛客网面试必刷 Top 101](https://www.nowcoder.com/exam/oj?tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=295&page=1)，可谓是经典中的经典，这些题我都整理好了，每个分类的标题就是对应的 LeetCode 链接。

#### [树](https://leetcode-cn.com/problem-list/zXvwZWi9/)

[二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

递归和迭代都很简单。

[二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

递归很简单，迭代不太好想，稍微需要注意下。

[二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

递归和迭代都很简单，它的迭代就是前序遍历的先遍历左子树的倒序，前序遍历的迭代会写，后序遍历的迭代就很简单了。

[二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

一个队列完事。

[二叉树的层序遍历||](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

同层序遍历思想，每次往列表头插即可。

[二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

同层序遍历思想，每次判断列表的 size%2 决定是头插还是尾插。

[二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

同层序遍历思想，每一层的最后一个元素即是结果。

[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

递归简单，迭代写法就是层序遍历的多少层。

[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

迭代写法和最大深度写法类似，不过需要注意，最小深度是从根节点到叶子节点，而左右子树为空时，是不构成子树的。迭代写法也是层序遍历，层序遍历的第一个叶子节点的深度就是最小深度。

[合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

递归写法很简单。

[平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

二叉树的最大深度会写，这道题也就不在话下了。

[对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

递归写法很简单，迭代写法一个队列完事，每次都是添加左左节点、右右节点、左右节点、右左节点即可。

[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

递归写法很简单。

[树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

递归写法很简单。

[验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

可以先中序遍历，然后验证其是递增的序列即可。还有一种递归写法是，验证每个节点在某个特定区间内（不能只简单判断左节点的值小于根节点，右节点的值大于根节点）。

[二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

递归写法很简单。

[二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

递归写法很简单。

[二叉搜索树中的第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

简单点就是从中序遍历序列里面找，这样写递归和迭代两种办法都行，还有一种解决办法就是算左子树的节点数，左子树的节点数是 K-1 的根节点就是第 K 小节点了。

[二叉搜索树的第 K 大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

简单点就是从中序遍历序列里面找，还有一种解决办法是，右子树的节点数是 K-1 的根节点就是第 K 大节点了。

[从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

思路：前序遍历的第一个节点是根节点，按照这个根节点在中序遍历一分为二，左边是左子树，右边是右子树，递归即可，需要注意递归终止条件以及左子树个树的计算。

[从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

思路同上：后序遍历的第一个节点是根节点，按照这个根节点在中序遍历一分为二，左边是左子树，右边是右子树，递归即可，需要注意递归终止条件以及左子树个树的计算。

[将有序数组转换为二叉搜索数](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

以数组的中间节点为根节点，数组左边区间为左子树，右边为右子树，递归即可。

[路径总和](https://leetcode-cn.com/problems/path-sum/)

递归写法很简单。

[路径总和||](https://leetcode-cn.com/problems/path-sum-ii/)

递归+回溯。

[路径总和|||](https://leetcode-cn.com/problems/path-sum-iii/)

DFS 解法，从每个节点往下找，找出以每个节点为根节的所有路径总数。

[二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

不会，待定。

#### [链表](https://leetcode-cn.com/problem-list/mt6I5uN1)

[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

迭代写法很简单，递归写法非常简洁。

[合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

迭代写法很简单，递归写法非常简洁。

[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

可以用 Set 来判断是否有环，空间复杂度 O(n)，空间复杂度 O(1) 即用快慢指针。

[环形链表||](https://leetcode-cn.com/problems/linked-list-cycle-ii)

快慢指针，慢指针和头节点同时走 a 步就是环入口，记住这么推导出来的就行了。fast = slow + bn，fast = 2slow，得出 slow = bn，而走到环入口一定是 a + bn，所以慢指针再走 a 步就可以到环入口了。

[链表中倒数第 K 个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

快慢指针。

[删除链表的倒数第 N 个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

简单的迭代解决。

[回文链表](https://leetcode-cn.com/problems/palindrome-linked-list)

采用反转链表的思想。

[链表的中间节点](https://leetcode-cn.com/problems/middle-of-the-linked-list)

快慢指针。

[相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)

简单的迭代解决。

[奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list)

简单的迭代解决。

[删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

简单的迭代解决。

[删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)

简单的迭代解决。

[两数相加](https://leetcode-cn.com/problems/add-two-numbers)

定义一个进位标记位，然后两个链表一块儿迭代解决。

[两数相加||](https://leetcode-cn.com/problems/add-two-numbers-ii/)

可以先反转再相加，或者也可以使用两个栈解决。
