---
第三方库
---

#### 目录

1. LeakCanary
2. Glide

#### LeakCanary

[LeakCanary](https://github.com/square/leakcanary/) 是一个内存泄漏检测的工具，内存泄露是指，不再使用的对象本应该要被回收，但是却没有被垃圾回收。

在 Android 中，哪些是不再使用的对象呢？比如已经回调了 onDestory 的 Activity 对象、已经回调 onFragmentDestroyed 的 Fragment、已经回调 onViewDetachedFromWindow 的 Dialog 等等。

那么怎么检测这些对象有没有被回收呢？

可以依赖于弱引用。每一个引用都可以关联一个引用队列，当这个引用被回收的时候，会把它添加到其关联的引用队列里面，我们可以通过观察引用队列有没有该引用而判断是否存在内存泄露。

这就是 LeakCanary 检测内存泄漏的核心原理。下面我再分为三步来描述 LeakCanary 的具体实现：

1. 注册回调
2. 检测泄漏
3. 输出结果

第一步注册回调是在 ContentProvider 中的 onCreate 方法中，这就避免了手动在 Application 注册。注册的回调有 Activity、Fragment、RootView、Service，Activity 可以使用 ActivityLifecycleCallbacks 把 onDestory 的 Activity 引用添加到 watchedObjects map 中，Fragment 的 FragmentLifecycleCallbacks 不仅会把 destory 的 Fragment 添加进去，也会把其 view 添加进去。RootView 监测的主要是 Dialog 泄漏，可以注册其 OnAttachStateChangeListener。Service 的内存泄露检测稍微有些麻烦，毕竟 Service 没有公开的 LifecycleCallbacks，它的检测实现依赖于 hook ActivityThread，代理其 Handler.Callback，当发现 mag.what 是 116 也就是 stopService 并且后续调用了 serviceDoneExecuting 就表明 Service 需要被回收了，添加到 map 中。

第二步是检测泄漏，有了这个 watchedObjects map 之后，这些弱引用都关联了同一个 ReferenceQueue，一旦其中的引用被回收了，就会从 map 中移除。然后在 delay 5s 再移除试试看，map 中仍然还存在的对象，就是内存泄露的对象。之所以 delay 5s 的原因，是因为两次 gc 最小的时间间隔时间是 5s。这个 postDelay 就是手动调用 Runtime.getRuntime().gc()，然后 sleep 100ms，让对象能够有足够的时间被添加到引用队列里面。

第三步输出结果就是在一个子线程 dump 出堆转储文件，然后使用 Shark 库的 HeapAnalyzer 来分析，也就是调用 HeapAnalyzer 的 analyze 方法就好了，具体的参数可从 Shark 的命令行库中获取。结果的 toString 就是 LeakCanary 的用户界面那么展示的泄漏引用链。





