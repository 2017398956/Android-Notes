---
卡顿优化
---

#### 目录

1. 基础知识
2. 卡顿排查工具
3. 卡顿监控

#### 基础知识

造成卡顿的原因可能有千百种，不过最终都会反映到 CPU 时间上。我们可以把 CPU 时间分为两种：用户时间和系统时间。用户时间就是执行用户态应用程序代码所消耗的时间；系统时间就是执行内核态系统调用所消耗的时间，包括 I/O、锁、中断以及其他系统调用的时间。

**CPU 性能**

评估一个 CPU 的性能，需要看主频、核心数、缓存等参数，具体表现出来的是计算能力和指令执行能力，也就是每秒执行的浮点数计算数和每秒执行的指令数。

我们可以通过以下方法获得设备的 CPU 信息：

```shell
// 获取 CPU 核心数
cat /sys/devices/system/cpu/possible  

// 获取某个 CPU 的频率
cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq
```

不过在 Android 8 之后，是没权限访问这些文件了。

**卡顿问题分析指标**

出现卡顿问题后，首先我们应该查看 CPU 的使用率。怎么查呢？我们可以通过 /proc/stat 得到整个系统的 CPU 使用情况，通过 /proc/[pid]/stat 可以得到某个进程的 CPU 使用情况。

其中比较重要的字段有：

```
proc/self/stat:
	utime: 用户时间，反应用户代码执行的耗时
	stime: 系统时间，反应系统调用执行的耗时
	majorFaults: 需要硬盘拷贝的缺页次数
	minorFaults: 无需硬盘拷贝的缺页次数
```

如果 CPU 使用率长期大于 60%，表示系统处于繁忙状态，就需要进一步分析用户时间和系统时间的比例。对于普通应用程序，系统时间不会长期高于 30%，如果超过这个值，我们就应该进一步检查是 I/O 过多，还是其他的系统调用问题。

除了 CPU 的使用率，我们还需要查看 CPU 饱和度。CPU 饱和度反映的是线程排队等待 CPU 的情况，也就是 CPU 的负载情况。

CPU 饱和度首先会跟应用的线程数有关，如果启动的线程过多，容易导致系统不断的切换执行的线程，把大量的时间浪费在上下文切换，我们知道每一次 CPU 上下文切换都需要刷新寄存器和计数器，至少需要几十纳秒的时间。

我们可以通过 /proc/[pid]/schedstat 文件来查看 CPU 上下文切换次数，特别需要注意被动切换的次数。

```
proc/self/sched:
  nr_voluntary_switches：     
  主动上下文切换次数，因为线程无法获取所需资源导致上下文切换，最普遍的是 IO。    
  nr_involuntary_switches：   
  被动上下文切换次数，线程被系统强制调度导致上下文切换，例如大量线程在抢占 CPU。
  se.statistics.iowait_count：IO 等待的次数
  se.statistics.iowait_sum：  IO 等待的时间
```

另外一个会影响 CPU 饱和度的是线程优先级，线程优先级会影响 Android 系统的调度策略，它主要由 nice 和 cgroup 类型共同决定。nice 值越低，抢占 CPU 时间片的能力越强。当 CPU 空闲时，线程的优先级对执行效率的影响并不会特别明显，但在 CPU 繁忙的时候，线程调度会对执行效率有非常大的影响。

关于线程优先级，你需要注意是否存在高优先级的线程空等低优先级线程，例如主线程等待某个后台线程的锁。

#### 卡顿排查工具

Traceview、systrace 以及 AS 自带的 Profiler 工具。

Traceview 可以用来查看整个过程有哪些函数调用，但是工具本身带来的性能开销过大，有时无法反应真实的情况。

systrace 可以用来跟踪系统的 I/O 操作、CPU 负载、Surface 渲染、GC 等事件。systrace 工具只能监控特定系统调用的耗时情况，而且性能开销非常低，但是它不支持应用程序代码的耗时分析，所以在使用时有一些局限性。

AS 3.2 自带的 Profiler 中直接集成了几种性能分析工具，其中：

* Sample Java Methods 的功能类似于 TraceView 的 sample 类型
* Trace Java Methods 的功能类似于 Traceview 的 instrument 类型
* Trace System Calls 的功能类似于 systrace
* SampleNative（API Level 26+）的功能类似于 Simpleperf

#### 卡顿监控

**消息队列**

基于消息队列的卡顿监控方案，是通过替换 Looper 的 Printer 实现，每一个消息的执行，都会在其前后打印日志，我们只需要设置这个 Printer，通过两次调用 println 的时间间隔，就是一个消息执行的耗时，但是 println 内有大量的字符串拼接，可能会导致性能损耗严重。



#### 参考

[卡顿优化（上）：你要掌握的卡顿分析方法](https://time.geekbang.org/column/article/71982)

[卡顿优化（下）：如何监控应用卡顿？](https://time.geekbang.org/column/article/72642)

[卡顿优化：卡顿现场与卡顿分析](https://time.geekbang.org/column/article/73277)

[Matrix Android TraceCanary](https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary)

[理解 Android ANR 的信息收集过程](http://gityuan.com/2016/12/02/app-not-response/)

[从源码角度看 CPU 相关日志](https://juejin.cn/post/6844903502733393927)

[深入探索 Android 卡顿优化](https://juejin.cn/post/6844904066259091469)

[https://developer.android.com/studio/profile/android-profiler](https://developer.android.com/studio/profile/android-profiler)

[https://developer.android.com/topic/performance/vitals/anr](https://developer.android.com/topic/performance/vitals/anr)

[https://github.com/markzhai/AndroidPerformanceMonitor](https://github.com/markzhai/AndroidPerformanceMonitor)

[https://github.com/xanderwang/performance](https://github.com/xanderwang/performance)
